import{r as c,j as b,t as m}from"./app-DEodmxZ4.js";function P(e,u){const t=c.createContext(u),f=r=>{const{children:n,...o}=r,i=c.useMemo(()=>o,Object.values(o));return b.jsx(t.Provider,{value:i,children:n})};f.displayName=e+"Provider";function s(r){const n=c.useContext(t);if(n)return n;if(u!==void 0)return u;throw new Error(`\`${r}\` must be used within \`${e}\``)}return[f,s]}function $(e,u=[]){let t=[];function f(r,n){const o=c.createContext(n),i=t.length;t=[...t,n];const d=l=>{const{scope:x,children:h,...v}=l,p=x?.[e]?.[i]||o,C=c.useMemo(()=>v,Object.values(v));return b.jsx(p.Provider,{value:C,children:h})};d.displayName=r+"Provider";function a(l,x){const h=x?.[e]?.[i]||o,v=c.useContext(h);if(v)return v;if(n!==void 0)return n;throw new Error(`\`${l}\` must be used within \`${r}\``)}return[d,a]}const s=()=>{const r=t.map(n=>c.createContext(n));return function(o){const i=o?.[e]||r;return c.useMemo(()=>({[`__scope${e}`]:{...o,[e]:i}}),[o,i])}};return s.scopeName=e,[f,w(s,...u)]}function w(...e){const u=e[0];if(e.length===1)return u;const t=()=>{const f=e.map(s=>({useScope:s(),scopeName:s.scopeName}));return function(r){const n=f.reduce((o,{useScope:i,scopeName:d})=>{const l=i(r)[`__scope${d}`];return{...o,...l}},{});return c.useMemo(()=>({[`__scope${u.scopeName}`]:n}),[n])}};return t.scopeName=u.scopeName,t}var S=globalThis?.document?c.useLayoutEffect:()=>{},g=m[" useInsertionEffect ".trim().toString()]||S;function R({prop:e,defaultProp:u,onChange:t=()=>{},caller:f}){const[s,r,n]=y({defaultProp:u,onChange:t}),o=e!==void 0,i=o?e:s;{const a=c.useRef(e!==void 0);c.useEffect(()=>{const l=a.current;l!==o&&console.warn(`${f} is changing from ${l?"controlled":"uncontrolled"} to ${o?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),a.current=o},[o,f])}const d=c.useCallback(a=>{if(o){const l=z(a)?a(e):a;l!==e&&n.current?.(l)}else r(a)},[o,e,r,n]);return[i,d]}function y({defaultProp:e,onChange:u}){const[t,f]=c.useState(e),s=c.useRef(t),r=c.useRef(u);return g(()=>{r.current=u},[u]),c.useEffect(()=>{s.current!==t&&(r.current?.(t),s.current=t)},[t,s]),[t,f,r]}function z(e){return typeof e=="function"}function j(e){const[u,t]=c.useState(void 0);return S(()=>{if(e){t({width:e.offsetWidth,height:e.offsetHeight});const f=new ResizeObserver(s=>{if(!Array.isArray(s)||!s.length)return;const r=s[0];let n,o;if("borderBoxSize"in r){const i=r.borderBoxSize,d=Array.isArray(i)?i[0]:i;n=d.inlineSize,o=d.blockSize}else n=e.offsetWidth,o=e.offsetHeight;t({width:n,height:o})});return f.observe(e,{box:"border-box"}),()=>f.unobserve(e)}else t(void 0)},[e]),u}export{j as a,S as b,$ as c,P as d,R as u};
